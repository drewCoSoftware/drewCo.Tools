//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
// Copyright ©2009-2020 Andrew A. Ritz, All Rights Reserved
//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

#if NETFX_CORE

using Windows.Storage;
using FTools = drewCo.Tools.FileTools;

#endif

//using iop = System.IO.File;


namespace drewCo.Tools
{

  // ============================================================================================================================
  /// <summary>
  /// This class is mean to be used as a way to formalize exception data so that it can be stored and analyzed for later use.
  /// It was originally provided as an expansion to the Exception -> XML code that was used in various bug reporting applications.
  /// </summary>
  public class ExceptionDetail
  {
    public string Type { get; private set; }
    public string Message { get; private set; }
    public string Comment { get; private set; }

    public ReadOnlyCollection<string> _StackTrace;
    public ReadOnlyCollection<string> StackTrace { get { return _StackTrace; } }

    public ExceptionDetail InnerException { get; private set; }

    /// <summary>
    /// This is used in cases where the source is an aggregate exception or similar.
    /// </summary>
    public List<ExceptionDetail> InnerExceptions { get; private set; }

    // --------------------------------------------------------------------------------------------------------------------------
    private ExceptionDetail() { }

    // --------------------------------------------------------------------------------------------------------------------------
    public ExceptionDetail(Exception ex)
      : this(ex, null)
    { }

    // --------------------------------------------------------------------------------------------------------------------------
    public ExceptionDetail(Exception ex, string comment_)
    {
      Type = ex.GetType().Name;
      Message = ex.Message;
      Comment = comment_;

      string[] trace = (ex.StackTrace != null) ? ex.StackTrace.Split(new[] { Environment.NewLine }, StringSplitOptions.None)
                                               : new string[] { };
      _StackTrace = new ReadOnlyCollection<string>(trace);

      // The inner exception on an aggregate is also the first item in its list of causes, so we skip it.      
      if (ex.InnerException != null && !(ex is AggregateException))
      {
        InnerException = new ExceptionDetail(ex.InnerException);
      }

      var agg = ex as AggregateException;
      if (agg != null)
      {
        InnerExceptions = new List<ExceptionDetail>();
        foreach (var e in agg.InnerExceptions)
        {
          InnerExceptions.Add(new ExceptionDetail(e));
        }
      }

    }

    // --------------------------------------------------------------------------------------------------------------------------
    /// <summary>
    /// Saves the exception data to disk, in the specified directory using sequential file names.
    /// </summary>
    /// <remarks>
    /// If the exception directory doesn't exist, it will be created.
    /// </remarks>
    /// <param name="noThrow">
    /// Any internal exceptions generated by this function will be swallowed, and it will return 'null'.
    /// Otherwise, the exception will be thrown.
    /// </param>
#if NETFX_CORE
    public static async Task<string> SaveExceptionData(Exception ex, string exDir, bool noThrow = true)
#else
    public static string SaveExceptionData(Exception ex, string exDir, bool noThrow = true)
#endif
    {
      try
      {
#if NETFX_CORE
        StorageFolder f = await FileTools.CreateDirectory(exDir);
#else
        FileTools.CreateDirectory(exDir);
#endif

#if NETFX_CORE
        ExceptionDetail ed = new ExceptionDetail(ex);
        string exPath = FileTools.GetSequentialFileName(f, "Exception", ".xml");
        StorageFile target = await FileTools.CreateFile(exPath, true);
        await FileTools.WriteAllText(target, ed.ToString());
#else
        ExceptionDetail ed = new ExceptionDetail(ex);
        string exPath = FileTools.GetSequentialFileName(exDir, "Exception", ".xml");
        ed.ToXML().Save(exPath);
#endif

        return exPath;
      }
      catch (Exception)
      {
        if (!noThrow)
        {
          throw;
        }
        // EMPTY:  This can't fail!
        return null;
      }
    }

    // --------------------------------------------------------------------------------------------------------------------------
    public XDocument ToXML()
    {
      return GetXMLInner(this);
    }

    // --------------------------------------------------------------------------------------------------------------------------
    public static XDocument GetExceptionDetailXML(Exception ex, string additionalInfo = "")
    {
      ExceptionDetail detail = new ExceptionDetail(ex, additionalInfo);
      return GetXMLInner(detail);
    }

    // --------------------------------------------------------------------------------------------------------------------------
    private static XDocument GetXMLInner(ExceptionDetail detail)
    {
      XElement xml = new XElement("ExceptionReport", new XAttribute("version", "2"), detail.ToXMLInner());
      XDocument res = new XDocument(new XDeclaration("1.0", "utf-8", "yes"), xml);
      return res;
    }

    // --------------------------------------------------------------------------------------------------------------------------
    private XElement ToXMLInner()
    {

      XElement res = new XElement("Exception");
      res.Add(new XElement("Message", Message));

      // Make sure all lines are present with breaks, etc.
      if (this.StackTrace != null)
      {
        var st = new XElement("StackTrace", string.Join(Environment.NewLine, StackTrace));
        res.Add(st);
      }


      if (this.InnerException != null)
      {
        XElement inner = new XElement("InnerException");
        inner.Add(this.InnerException.ToXMLInner());
        res.Add(inner);
      }
      if (this.InnerExceptions != null)
      {
        XElement inners = new XElement("InnerExceptions");
        foreach (var i in InnerExceptions)
        {
          inners.Add(i.ToXMLInner());
        }
        res.Add(inners);
      }


      if (this.Comment != "")
      {
        res.Add(new XElement("AdditionalInfo", this.Comment));
      }

      return res;
    }


    // --------------------------------------------------------------------------------------------------------------------------
    public static ExceptionDetail FromXML(XDocument doc)
    {
      XElement root = doc.Root;
      if (root.Name != "ExceptionReport") { throw new InvalidOperationException("Invalid root node!"); }

      var vAttr = root.Attribute("version");
      int version = vAttr == null ? 1 : int.Parse(vAttr.Value);

      ExceptionDetail detail = FromXMLChild(root.Element("Exception"), version);

      return detail;

    }

    // --------------------------------------------------------------------------------------------------------------------------
    private static ExceptionDetail FromXMLChild(XElement src, int version)
    {
      ExceptionDetail res = new ExceptionDetail();
      res.Message = (from x in src.Elements("Message") select x.Value).SingleOrDefault();
      res.Comment = (from x in src.Elements("AdditionalInfo") select x.Value).SingleOrDefault();

      var traceLines = (from x in src.Elements("StackTrace") select x.Value).SingleOrDefault();
      if (!string.IsNullOrEmpty(traceLines))
      {
        var stLines = traceLines.Split(new[] { Environment.NewLine }, StringSplitOptions.None);
        res._StackTrace = new ReadOnlyCollection<string>(stLines);
      }

      // Inner exception.
      XElement innerException = null;
      if (version == 1)
      {
        innerException = src.Element("Exception");
        if (innerException != null)
        {
          res.InnerException = FromXMLChild(innerException, version);
        }
      }
      else if (version == 2)
      {
        innerException = src.Element("InnerException");
        if (innerException != null)
        {
          res.InnerException = FromXMLChild(innerException.Element("Exception"), version);
        }
      }
      else
      {
        throw new NotImplementedException(string.Format("Unsupported version! ({0})", version));
      }


      // Inner exceptions (aggregate)
      if (version == 1)
      {
        // Not supported in v1.
        res.InnerExceptions = null;
      }
      else if (version == 2)
      {
        var aggExceptions = src.Element("InnerExceptions");
        if (aggExceptions != null)
        {
          res.InnerExceptions = new List<ExceptionDetail>();
          foreach (var ie in aggExceptions.Elements("Exception"))
          {
            res.InnerExceptions.Add(FromXMLChild(ie, version));
          }
        }
      }
      else
      {
        throw new NotImplementedException(string.Format("Unsupported version! ({0})", version));
      }

      return res;

    }

    // --------------------------------------------------------------------------------------------------------------------------
    public override string ToString()
    {
      return this.ToXML().ToString();
    }

  }
}
